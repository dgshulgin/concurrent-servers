package main

import "fmt"

// Pattern Generator

// Вообще говоря, главным героем этого паттерна является вовсе не горутина, а канал. Именно он обеспечивает синхронизацию между генератором значений и потребителем значений. Работает как коромысло (двуплечий рычаг): после того как значение записано в канал (генератор), из него можно только читать (потребитель), а запись блокируется. После того, как значение прочитано (потребитель), дальнейшее чтение блокируется, но становится возможной запись (генератор). Так он и качает, пока генератор не устанет создавать значения и не закроет канал. Прочитав последнее значение из канала потребитель также завершит свой цикл обработки, читать из закрытого канала невозможно. Обратите внимание, именно генератор закрывает канал (!), сигнализируя о том, что передача значений завершена.

// Горутина генератора и горутина main работают одновременно, качая это коромысло.

// А вот и генератор, функция которая возвращает нам значения по однму. Заметным преимуществом является то что со значениями можно работать с помощью range.
// Обратите внимание что функция возвращает канал "только для чтения". Здесь стрелка во-первых повышает читаемость кода, во-вторых - дает защиту на уровне компилятора от, возможно, ошибочной попытки записи в этот канал.
func gen() <-chan int {
	out := make(chan int, 1)

	go func() {
		for v := 0; v < 20; v++ {
			out <- v
		}
		close(out)
	}()

	return out
}

// а вот и пользователь генератора
// таким образом можно разделить формирование значение и использование значение, при этом выполнять обе части процесса одновременно. Для синхрониации ничего не надо делать руками, синхронизацию обеспечивает небуферизованный канал "из коробки".
func main() {
	for v := range gen() {
		fmt.Println(v)
	}
}

// Накой это все ? Можно же собрать значения в слайс и обрабатывать его.
// 1. В реальном проекте значение (обращение к серверу) может поступить в любой момент, например, когда обработчик не готов принять его. Схема позволяет организовать накопление входяищх значений.
// 2. В реальном проекте данных может быть слишеом много для того, чтобы собрать их и поместить в один слайс.
