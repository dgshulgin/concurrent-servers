## Pattern Generator

Вообще говоря, главным героем этого паттерна является вовсе не горутина, а канал. Именно он обеспечивает синхронизацию между генератором значений и потребителем значений. Работает как коромысло (двуплечий рычаг): после того как значение записано в канал (генератор), из него можно только читать (потребитель), а запись блокируется. После того, как значение прочитано (потребитель), дальнейшее чтение блокируется, но становится возможной запись (генератор). Так он и качает, пока генератор не устанет создавать значения и не закроет канал. Прочитав последнее значение из канала потребитель также завершит свой цикл обработки, читать из закрытого канала невозможно. Обратите внимание, именно генератор закрывает канал (!), сигнализируя о том, что передача значений завершена.

Горутина генератора и горутина main работают одновременно, качая это коромысло.

А вот и генератор, функция которая возвращает нам значения по однму. Заметным преимуществом является то что со значениями можно работать с помощью range.
Обратите внимание что функция возвращает канал "только для чтения". Здесь стрелка во-первых повышает читаемость кода, во-вторых - дает защиту на уровне компилятора от, возможно, ошибочной попытки записи в этот канал.

```go
func gen() <-chan int {
	out := make(chan int, 1)

	go func() {
		for v := 0; v < 20; v++ {
			out <- v
		}
		close(out)
	}()

	return out
}
```

А вот и потребитель значений генератора.
```go
func main() {
	for v := range gen() {
		fmt.Println(v)
	}
}
```

Таким образом можно разделить формирование значение и использование значение, при этом выполнять обе части процесса одновременно. Приятно, что для синхронизации работы горутин ничего не надо делать руками, синхронизацию обеспечивает канал.

Накой это все ? Можно же собрать значения в слайс и обрабатывать его.
1. В реальном проекте значение (обращение к серверу) может поступить в любой момент, например, когда потребитель не готов принять его. Схема позволяет организовать накопление входящих значений.
2. В реальном проекте данных может быть слишком много для того, чтобы собрать их и поместить в один слайс.